<html>
<head></head>
<body>
	<div>
		<canvas id="canvas" tabindex="1" width="800" height="100"></canvas>
	</div>
	<script src="axe.js"></script>
	<script src="point.js"></script>
	<script src="rectangle.js"></script>
	<script src="canvas.js"></script>
	<script>
	function schedule(loop, period) {
		loop(0);
		setInterval(function(){
			loop(period)
		}, period * 1000);
	}

	var Square = {
		x: 0, 
		selected: false,
		states: {
			Moving: { 
				update: function(t) {
					this.x += 50 * t;
				}
			}, 
			Stopped: {
				update: function(t) {}
			}
		},
		update: function(t) {
			this.state = this.state || this.states.Moving;
			this.state.update.call(this, t); 
		},
		mouseDown: function() {
			this.selected = !this.selected;
		},
		keyPress: function(keyCode){
			if(this.selected && keyCode === 37) this.x -= 50
		},
		collide: function()	{
			this.state = this.states.Stopped;
		},
		render: function(canvas) {
			canvas.drawRectangle(this.bound, this.selected ? '#0ED600' : '#8ED6FF');
		},
		get bound() {
			return new Rectangle(this.x, 0, 100, 100)
		}
	};

	var Wall = { 
		hitted: false, 
		render: function(canvas) {
			canvas.drawRectangle(this.bound, this.hitted ? '#FF2020' : null);
		},
		collide: function() {
			this.hitted = true;
		},
		get bound() {
			return new Rectangle(400, 0, 10, 180)
		}
	};

	function ActorRef(actor){
		this._actor = actor;
	}

	ActorRef.prototype = {
		tell: function(action, arg) {
			var definition = this._actor._definition;
			var mailbox = this._actor.mailbox;
			mailbox.push(function(){
				var handler = definition[action];
				handler && handler.call(definition, arg);
			});
		}
	}

	function Actor(definition) {
		this._definition = definition;
		this._ref = new ActorRef(this);
	}

	Actor.prototype = {
		mailbox: [],
		get ref() {
			return this._ref;
		},
		run: function() {
			var mailbox = this.mailbox;
			this.mailbox = [];
			mailbox.forEach(function(it){ it() });
		},
		render: function(canvas) {
			this._definition.render(canvas)
		},
		get bound() {
			return this._definition.bound
		}
	}

	function Game(period, canvas, objects) {
		this.period = period;
		this.canvas = canvas;
		this.objects = objects;
		this.canvas.onMouseDown(this.onMouseDown.bind(this));
		this.canvas.onKeyPress(this.onKeyPress.bind(this));
	}

	Game.prototype = {
		actors: [],
		get refs() {
			return this.actors.map(function(actor){
				return actor.ref
			})
		},
		createActor: function(definition){
			this.actors.push(new Actor(definition))
		},
		dispatch: function(action, _this){
			this.refs.forEach(action, _this);
		},
		exec: function(action, _this) {
			this.actors.forEach(action, _this);
		},
		onMouseDown: function(e) {
			var point = new Point(e.pageX, e.pageY) 
			this.exec(function(actor){
				if(point.within(actor.bound)) {
					actor.ref.tell('mouseDown', point);
				}	
			})
		},
		onKeyPress: function(e) {
			this.dispatch(function(ref){
				ref.tell('keyPress', e.keyCode)
			})
		},
		updateTime: function(t) {
			this.dispatch(function(ref) {
				ref.tell('update', t);
			});
		}, 
		updateCollisions: function() {
			this.exec(function(actor){
				this.exec(function(actor2) {
					if(actor !== actor2 && actor.bound.collides(actor2.bound)) {
						actor.ref.tell('collide', actor2.ref);
					}
				})
			}, this);
		},
		update: function(t) {
			this.updateCollisions();
			this.updateTime(t);

			this.exec(function(actor){ 
				actor.run();
			})
		},
		render: function() {
			this.canvas.clear();
			this.exec(function(actor){
				actor.render(this.canvas);
			}, this)
		}, 
		loop: function (t) {
			this.update(t);
			this.render();
		},
		run: function() {
			schedule(this.loop.bind(this), this.period)
		}
	}


	var canvas1 = new Canvas('canvas');
	var game = new Game(0.1, canvas1);
	game.createActor(Square)
	game.createActor(Wall)
	game.run();
	//entity: actor(id + state + behaviour) + bounding + visual rendering 
	</script>
</body>
</html>
