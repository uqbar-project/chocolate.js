<html>
<head></head>
<body>
	<div>
		<canvas id="canvas" width="800" height="100"></canvas>
	</div>
	<div>
		<canvas id="canvas2" width="800" height="100"></canvas>
	</div>
	<div>
		<canvas id="canvas3" width="800" height="100"></canvas>
	</div>
	<script>

	function Canvas(id) {
		this.innerCanvas = document.getElementById(id);
		this.context = this.innerCanvas.getContext('2d');
	}
	Canvas.prototype = {
		drawRectangle: function(myRectangle) {
			this.context.beginPath();
			this.context.rect(myRectangle.x, myRectangle.y, myRectangle.width, myRectangle.height);
			this.context.fillStyle = '#8ED6FF';
			this.context.fill();
			this.context.lineWidth = myRectangle.borderWidth;
			this.context.strokeStyle = 'black';
			this.context.stroke();
		}, 
		clear: function(){
			this.context.clearRect(0, 0, this.innerCanvas.width, this.innerCanvas.height)
		}
	}

	function collides(bound1, bound2) {
		function collideAxe(axe, dimmension) {
			return (axe(bound2) >= axe(bound1) && axe(bound2) <= axe(bound1) + dimmension(bound1))
		}
		return collideAxe(function(it){return it.x}, function(it) { return it.width }) && 
		collideAxe(function(it){return it.y}, function(it) { return it.height });
	}

	function schedule(loop, period) {
		loop(0);
		setInterval(function(){
			loop(period)
		}, period * 1000);
	}

	var Game = {
		objects: [{
			x: 0, 
			states: {
				Moving: { 
					update: function(t) {
						this.x += 10 * t;
					}
				}, 
				Stopped: {
					update: function(t) { }
				}
			},
			update: function(t) {
				this.state = this.state || this.states.Moving;
				this.state.update.call(this, t); 
			},
			collide: function()	{
				this.state = this.states.Stopped;
			},
			render: function(canvas) {
				canvas.drawRectangle(this.bound);
			},
			get bound() {
				return {x: this.x, y: 0, width: 100, height: 100};
			}
		}, { 
			update: function(t) {},
			collide: function() {},
			render: function(canvas) {
				canvas.drawRectangle(this.bound);
			},
			get bound() {
				return {x: 200, y: 0, width: 10, height: 180};
			}
		}],
		updateTime: function(t) {
			this.objects.forEach(function(o){
				o.update(t);
			});
		}, 
		updateCollisions: function() {
			var collisions = []
			this.objects.forEach(function(o){
				this.objects.forEach(function(o2) {
					if(o !== o2 && collides(o.bound, o2.bound)) {
						collisions.push({ from: o, to: o2 });
					}
				})
			}, this);
			collisions.forEach(function(c){
				c.from.collide(c.to);
			})
		},
		update: function(t) {
			this.updateTime(t);
			this.updateCollisions();
		},
		render: function() {
			this.canvas.clear();
			this.objects.forEach(function(o){
				o.render(this.canvas);
			}, this)
		}, 
		loop: function (t) {
			this.update(t);
			this.render();
		},
		run: function() {
			schedule(this.loop.bind(this), this.period)
		}
	}

	function runGame(period, canvas) {
		var game = Object.create(Game);
		game.period = period;
		game.canvas = canvas;
		game.run();
	}

	var canvas1 = new Canvas('canvas');
	var canvas2 = new Canvas('canvas2');
	var canvas3 = new Canvas('canvas3');

	runGame(1, canvas1);
	runGame(0.5, canvas2);
	runGame(0.1, canvas3);
	//entity: actor(id + state + behaviour) + bounding + visual rendering 
	</script>
</body>
</html>
