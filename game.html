<html>
<head></head>
<body>
	<div>
		<canvas id="canvas" tabindex="1" width="800" height="100"></canvas>
	</div>
	<script src="axe.js"></script>
	<script src="point.js"></script>
	<script src="rectangle.js"></script>
	<script src="canvas.js"></script>
	<script>
	function schedule(loop, period) {
		loop(0);
		setInterval(function(){
			loop(period)
		}, period * 1000);
	}

	function tell(entity, action, args) {
		entity.mailbox.push(function(){
			var handler = entity[action];
			handler && handler.call(entity, args);
		});
	}

	function run(entity) {
		var mailbox = entity.mailbox;
		entity.mailbox = [];
		mailbox.forEach(function(it){ it() });
	}

	var Square = {
		x: 0, 
		selected: false,
		mailbox: [],
		states: {
			Moving: { 
				update: function(t) {
					this.x += 50 * t;
				}
			}, 
			Stopped: {
				update: function(t) {}
			}
		},
		update: function(t) {
			this.state = this.state || this.states.Moving;
			this.state.update.call(this, t); 
		},
		mouseDown: function() {
			this.selected = !this.selected;
		},
		keyPress: function(keyCode){
			if(this.selected && keyCode === 37) this.x -= 50
		},
		collide: function()	{
			this.state = this.states.Stopped;
		},
		render: function(canvas) {
			canvas.drawRectangle(this.bound, this.selected ? '#0ED600' : '#8ED6FF');
		},
		get bound() {
			return new Rectangle(this.x, 0, 100, 100)
		}
	};

	var Wall = { 
		mailbox: [],
		hitted: false, 
		render: function(canvas) {
			canvas.drawRectangle(this.bound, this.hitted ? '#FF2020' : null);
		},
		collide: function() {
			this.hitted = true;
		},
		get bound() {
			return new Rectangle(400, 0, 10, 180)
		}
	};

	function Game(period, canvas, objects) {
		this.period = period;
		this.canvas = canvas;
		this.objects = objects;
		this.canvas.onMouseDown(this.onMouseDown.bind(this));
		this.canvas.onKeyPress(this.onKeyPress.bind(this));
	}

	Game.prototype = {
		dispatch: function(action, self){
			this.objects.forEach(action, self);
		},
		onMouseDown: function(e) {
			var point = new Point(e.pageX, e.pageY) 
			this.dispatch(function(entity){
				if(point.within(entity.bound)) {
					tell(entity, 'mouseDown', point);
				}	
			})
		},
		onKeyPress: function(e) {
			this.dispatch(function(entity){
				tell(entity, 'keyPress', e.keyCode)
			})
		},
		updateTime: function(t) {
			this.dispatch(function(o) {
				tell(o, 'update', t);
			});
		}, 
		updateCollisions: function() {
			this.objects.forEach(function(o){
				this.objects.forEach(function(o2) {
					if(o !== o2 && o.bound.collides(o2.bound)) {
						tell(o, 'collide', o2);
					}
				})
			}, this);
		},
		update: function(t) {
			this.updateCollisions();
			this.updateTime(t);


			this.dispatch(function(o){ 
				run(o);
			})
		},
		render: function() {
			this.canvas.clear();
			this.dispatch(function(o){
				o.render(this.canvas);
			}, this)
		}, 
		loop: function (t) {
			this.update(t);
			this.render();
		},
		run: function() {
			schedule(this.loop.bind(this), this.period)
		}
	}


	var canvas1 = new Canvas('canvas');
	var game = new Game(0.1, canvas1, [Square, Wall]);
	game.run();
	//entity: actor(id + state + behaviour) + bounding + visual rendering 
	</script>
</body>
</html>
