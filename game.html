<html>
<head></head>
<body>
	<div>
		<canvas id="canvas" width="800" height="100"></canvas>
	</div>
	<script src="axe.js"></script>
	<script src="point.js"></script>
	<script src="rectangle.js"></script>
	<script src="canvas.js"></script>
	<script>
	function schedule(loop, period) {
		loop(0);
		setInterval(function(){
			loop(period)
		}, period * 1000);
	}

	function tell(entity, action, args) {
		entity.mailbox.push(function(){
			var handler = entity[action];
			handler && handler.call(entity, args);
		});
	}

	function run(entity) {
		var mailbox = entity.mailbox;
		entity.mailbox = [];
		mailbox.forEach(function(it){ it() });
	}

	var Square = {
		x: 0, 
		color: '#8ED6FF',
		mailbox: [],
		states: {
			Moving: { 
				update: function(t) {
					this.x += 30 * t;
				}
			}, 
			Stopped: {
				update: function(t) {}
			}
		},
		update: function(t) {
			this.state = this.state || this.states.Moving;
			this.state.update.call(this, t); 
		},
		mouseDown: function() {
			this.color = '#0ED600';
		},
		collide: function()	{
			this.state = this.states.Stopped;
		},
		render: function(canvas) {
			canvas.drawRectangle(this.bound, this.color);
		},
		get bound() {
			return new Rectangle(this.x, 0, 100, 100)
		}
	};

	var Wall = { 
		mailbox: [],
		render: function(canvas) {
			canvas.drawRectangle(this.bound);
		},
		get bound() {
			return new Rectangle(400, 0, 10, 180)
		}
	};

	function Game(period, canvas, objects) {
		this.period = period;
		this.canvas = canvas;
		this.objects = objects;
		this.canvas.onMouseDown(function(e) {
			game.eventQueue.push(function(entity) {
				var point = new Point(e.pageX, e.pageY) 
				if(point.within(entity.bound)) {
					tell(entity, 'mouseDown', point);
				}
			})
		}.bind(this))
	}

	Game.prototype = {
		eventQueue: [],
		updateTime: function(t) {
			this.objects.forEach(function(o) {
				tell(o, 'update', t);
			});
		}, 
		updateCollisions: function() {
			this.objects.forEach(function(o){
				this.objects.forEach(function(o2) {
					if(o !== o2 && o.bound.collides(o2.bound)) {
						tell(o, 'collide', o2);
					}
				})
			}, this);
		},
		updateEvents: function() {
			this.eventQueue.forEach(function(e){
				this.objects.forEach(function(o) {
					e(o);
				})
			}, this)
			this.eventQueue = [];
		},

		update: function(t) {
			this.updateEvents();
			this.updateCollisions();
			this.updateTime(t);


			this.objects.forEach(function(o){ 
				run(o);
			})
		},
		render: function() {
			this.canvas.clear();
			this.objects.forEach(function(o){
				o.render(this.canvas);
			}, this)
		}, 
		loop: function (t) {
			this.update(t);
			this.render();
		},
		run: function() {
			schedule(this.loop.bind(this), this.period)
		}
	}


	var canvas1 = new Canvas('canvas');
	var game = new Game(0.1, canvas1, [Square, Wall]);
	game.run();
	//entity: actor(id + state + behaviour) + bounding + visual rendering 
	</script>
</body>
</html>
