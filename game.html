<html>
<head></head>
<body>
	<div>
		<canvas id="canvas" width="800" height="100"></canvas>
	</div>
	<script>

	function Canvas(id) {
		this.innerCanvas = document.getElementById(id);
		this.context = this.innerCanvas.getContext('2d');
	}
	Canvas.prototype = {
		onMouseDown: function(callback) {
			this.innerCanvas.addEventListener('mousedown', callback, false);
		},
		drawRectangle: function(myRectangle, color) {
			this.context.beginPath();
			this.context.rect(myRectangle.x, myRectangle.y, myRectangle.width, myRectangle.height);
			this.context.fillStyle =  color || '#8ED6FF';
			this.context.fill();
			this.context.lineWidth = myRectangle.borderWidth;
			this.context.strokeStyle = 'black';
			this.context.stroke();
		}, 
		clear: function(){
			this.context.clearRect(0, 0, this.innerCanvas.width, this.innerCanvas.height)
		}
	}

	function collides(bound1, bound2) {
		return within(bound1, bound2) || 
		within({x: bound1.x + bound1.width, y: bound1.y}, bound2) || 
		within({x: bound1.x, y: bound1.y + bound1.height}, bound2)  ||
		within({x: bound1.x + bound1.width, y: bound1.y + bound1.height}, bound2)
	}

	function within(point, bound) {
		function withinAxe(axe, dimmension) {
			return (axe(point) >= axe(bound) && axe(point) <= axe(bound) + dimmension(bound))
		}
		return withinAxe(function(it){return it.x}, function(it) { return it.width }) && 
		withinAxe(function(it){return it.y}, function(it) { return it.height });
	}

	function schedule(loop, period) {
		loop(0);
		setInterval(function(){
			loop(period)
		}, period * 1000);
	}

	function tell(entity, action, args) {
		entity.mailbox.push(function(){
			var handler = entity[action];
			handler && handler.call(entity, args);
		});
	}

	function run(entity) {
		var mailbox = entity.mailbox;
		entity.mailbox = [];
		mailbox.forEach(function(it){ it() });
	}

	var Game = {
		objects: [{
			x: 0, 
			color: '#8ED6FF',
			mailbox: [],
			states: {
				Moving: { 
					update: function(t) {
						this.x += 30 * t;
					}
				}, 
				Stopped: {
					update: function(t) { }
				}
			},
			update: function(t) {
				this.state = this.state || this.states.Moving;
				this.state.update.call(this, t); 
			},
			mouseDown: function() {
				this.color = '#0ED600';
			},
			collide: function()	{
				this.state = this.states.Stopped;
			},
			render: function(canvas) {
				canvas.drawRectangle(this.bound, this.color);
			},
			get bound() {
				return {x: this.x, y: 0, width: 100, height: 100};
			}
		}, { 
			mailbox: [],
			render: function(canvas) {
				canvas.drawRectangle(this.bound);
			},
			get bound() {
				return {x: 400, y: 0, width: 10, height: 180};
			}
		}],
		eventQueue: [],
		updateTime: function(t) {
			this.objects.forEach(function(o) {
				//o.update(t);
				tell(o, 'update', t);
			});
		}, 
		updateCollisions: function() {
			this.objects.forEach(function(o){
				this.objects.forEach(function(o2) {
					if(o !== o2 && collides(o.bound, o2.bound)) {
						tell(o, 'collide', o2);
					}
				})
			}, this);
		},
		updateEvents: function() {
			this.eventQueue.forEach(function(e){
				this.objects.forEach(function(o) {
					e(o);
				})
			}, this)
			this.eventQueue = [];
		},

		update: function(t) {
			this.updateEvents();
			this.updateCollisions();
			this.updateTime(t);


			this.objects.forEach(function(o){ 
				run(o);
			})
		},
		render: function() {
			this.canvas.clear();
			this.objects.forEach(function(o){
				o.render(this.canvas);
			}, this)
		}, 
		loop: function (t) {
			this.update(t);
			this.render();
		},
		run: function() {
			schedule(this.loop.bind(this), this.period)
		}
	}

	function runGame(period, canvas) {
		var game = Object.create(Game);
		game.period = period;
		game.canvas = canvas;
		game.canvas.onMouseDown(function(e) {
			game.eventQueue.push(function(entity) {
				//console.log('E' + entity.bound.x +":"+ entity.bound.y +":"+ entity.bound.width +":"+ entity.bound.height )
				//console.log('P' + e.pageX +":"+ e.pageY)
				if(within({x: e.pageX, y: e.pageY}, entity.bound)) {
					//console.log('within')
					tell(entity, 'mouseDown', e.pageX, e.pageY);
				}
			})
		})
		game.run();
	}

	var canvas1 = new Canvas('canvas');
	runGame(0.1, canvas1);
	//entity: actor(id + state + behaviour) + bounding + visual rendering 
	</script>
</body>
</html>
